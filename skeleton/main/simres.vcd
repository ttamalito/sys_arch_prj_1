$date
	Wed Jun 14 14:15:40 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 5 memtoreg $end
$var wire 1 6 dojump $end
$var wire 1 7 dobranch $end
$var wire 5 8 destreg [4:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 32 : aluout [31:0] $end
$var wire 3 ; alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 < instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 = op [5:0] $end
$var wire 6 > funct [5:0] $end
$var reg 3 ? alucontrol [2:0] $end
$var reg 1 9 alusrcbimm $end
$var reg 5 @ destreg [4:0] $end
$var reg 1 7 dobranch $end
$var reg 1 6 dojump $end
$var reg 1 5 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 3 A alucontrol [2:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 B destreg [4:0] $end
$var wire 1 7 dobranch $end
$var wire 32 C instr [31:0] $end
$var wire 1 6 jump $end
$var wire 1 5 memtoreg $end
$var wire 32 D readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 E writedata [31:0] $end
$var wire 32 F zero_left_wire [31:0] $end
$var wire 1 1 zero $end
$var wire 32 G srcbimm [31:0] $end
$var wire 32 H srcb [31:0] $end
$var wire 32 I srca [31:0] $end
$var wire 32 J signimm [31:0] $end
$var wire 32 K result [31:0] $end
$var wire 32 L pc [31:0] $end
$var wire 32 M paddwire [31:0] $end
$var wire 32 N jal_wire [31:0] $end
$var wire 32 O aluout [31:0] $end
$scope module alu $end
$var wire 32 P a_and_b [31:0] $end
$var wire 32 Q a_or_b [31:0] $end
$var wire 3 R alucontrol [2:0] $end
$var wire 32 S b [31:0] $end
$var wire 1 T first_xor $end
$var wire 1 U second_xor $end
$var wire 1 1 zero $end
$var wire 32 V sum [31:0] $end
$var wire 32 W result [31:0] $end
$var wire 32 X extend [31:0] $end
$var wire 32 Y b_multi [31:0] $end
$var wire 32 Z a [31:0] $end
$upscope $end
$scope module back $end
$var wire 16 [ a [15:0] $end
$var wire 32 \ y [31:0] $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 ] ra1 [4:0] $end
$var wire 5 ^ ra2 [4:0] $end
$var wire 5 _ wa3 [4:0] $end
$var wire 32 ` wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 a rd2 [31:0] $end
$var wire 32 b rd1 [31:0] $end
$upscope $end
$scope module padd $end
$var wire 16 c a [15:0] $end
$var wire 32 d y [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 32 e aluResult [31:0] $end
$var wire 1 ! clk $end
$var wire 1 7 dobranch $end
$var wire 1 6 dojump $end
$var wire 32 f jr_pc [31:0] $end
$var wire 26 g jumptarget [25:0] $end
$var wire 6 h least_sig_bits [5:0] $end
$var wire 6 i opCode [5:0] $end
$var wire 32 j pc_plus [31:0] $end
$var wire 32 k progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 l nextpc [31:0] $end
$var wire 32 m incpc [31:0] $end
$var wire 32 n branchpc [31:0] $end
$var wire 32 o branchoffset [31:0] $end
$var reg 32 p pc [31:0] $end
$scope module pcbranch $end
$var wire 32 q b [31:0] $end
$var wire 1 r cin $end
$var wire 32 s y [31:0] $end
$var wire 1 t cout $end
$var wire 32 u a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 v a [31:0] $end
$var wire 32 w b [31:0] $end
$var wire 1 x cin $end
$var wire 32 y y [31:0] $end
$var wire 1 z cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 { a [15:0] $end
$var wire 32 | y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11 |
b11 {
0z
b10000000000000000000100 y
0x
b100 w
b10000000000000000000000 v
b10000000000000000000100 u
0t
b10000000000000000010000 s
0r
b1100 q
b10000000000000000000000 p
b11 o
b10000000000000000010000 n
b10000000000000000000100 m
b10000000000000000001100 l
b10000000000000000000000 k
b10000000000000000000100 j
b11 i
b11 h
b100000000000000000011 g
b0 f
b11001010111111101011101010111110 e
b11 d
b11 c
b0 b
b11001010111111101011101010111110 a
b10000000000000000000100 `
b11111 _
b10000 ^
b0 ]
b110000000000000000 \
b11 [
b0 Z
b11001010111111101011101010111110 Y
b0 X
b11001010111111101011101010111110 W
b11001010111111101011101010111110 V
0U
1T
b11001010111111101011101010111110 S
b10 R
b11001010111111101011101010111110 Q
b0 P
b11001010111111101011101010111110 O
b10000000000000000000100 N
b110000000000000000 M
b10000000000000000000000 L
b10000000000000000000100 K
b11 J
b0 I
b11001010111111101011101010111110 H
b11001010111111101011101010111110 G
b11 F
b11001010111111101011101010111110 E
bx D
b1100000100000000000000000011 C
b11111 B
b10 A
b11111 @
b10 ?
b11 >
b11 =
b1100000100000000000000000011 <
b10 ;
b11001010111111101011101010111110 :
09
b11111 8
07
16
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b1100000100000000000000000011 /
b1100000100000000000000000011 .
b0 -
b11001010111111101011101010111110 ,
bx +
b101111 *
b11001010111111101011101010111110 )
0(
b1100000100000000000000000011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
1!
#5
0"
#6
0!
#8
b11110 *
b1111011 )
b1111011 :
b1111011 O
b1111011 W
b1111011 e
0T
b1111011 V
b1111011 Q
b1111011 Y
b1111011 G
b1111011 S
b10000000000000000010000 l
b111101100 q
b10000000000000111111100 n
b10000000000000111111100 s
b1111011 K
b1111011 `
06
19
b101 8
b101 @
b101 B
b101 _
b1001 =
b111011 >
b1010000000001111011 g
b1001 i
b111011 h
b1111011 J
b1111011 o
b1111011 |
b1111011 {
b11110110000000000000000 M
b11110110000000000000000 \
b1111011 [
b1111011 F
b1111011 d
b1111011 c
b101 ^
b10000000000000000010000 N
b10000000000000000010000 j
b10000000000000000010000 m
b10000000000000000010000 u
b10000000000000000010000 y
b100100000001010000000001111011 '
b100100000001010000000001111011 .
b100100000001010000000001111011 /
b100100000001010000000001111011 <
b100100000001010000000001111011 C
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 L
b10000000000000000001100 k
b10000000000000000001100 p
b10000000000000000001100 v
1!
#10
0!
#12
b10000000000000000000100 K
b10000000000000000000100 `
b1 *
b10000000000000000000100 )
b10000000000000000000100 :
b10000000000000000000100 O
b10000000000000000000100 W
b10000000000000000000100 e
b0 Y
b0 G
b0 S
b10000000000000000000100 l
b10000000000000000000100 V
b10000000000000000000100 Q
b100000 q
b10000000000000000000100 I
b10000000000000000000100 Z
b10000000000000000000100 b
b10000000000000000000100 f
b10000000000000000110100 n
b10000000000000000110100 s
16
09
bx 8
bx @
bx B
bx _
03
b0 =
b1000 >
b11111000000000000000001000 g
b0 i
b1000 h
b1000 J
b1000 o
b1000 |
b1000 {
b10000000000000000000 M
b10000000000000000000 \
b1000 [
b1000 F
b1000 d
b1000 c
b11111 ]
b0 ^
b0 $
b0 ,
b0 2
b0 E
b0 H
b0 a
b10000000000000000010100 N
b10000000000000000010100 j
b10000000000000000010100 m
b10000000000000000010100 u
b10000000000000000010100 y
b11111000000000000000001000 '
b11111000000000000000001000 .
b11111000000000000000001000 /
b11111000000000000000001000 <
b11111000000000000000001000 C
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 L
b10000000000000000010000 k
b10000000000000000010000 p
b10000000000000000010000 v
1!
#14
0!
#16
b111001000 K
b111001000 `
01
b110010 *
b111001000 )
b111001000 :
b111001000 O
b111001000 W
b111001000 e
b111001000 Y
b111001000 G
b111001000 S
b10000000000000000001000 l
b111001000 V
b111001000 Q
b11100100000 q
b0 I
b0 Z
b0 b
b0 f
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 E
b11001010111111101011101010111110 H
b11001010111111101011101010111110 a
b10000000000011100101000 n
b10000000000011100101000 s
06
19
b110 8
b110 @
b110 B
b110 _
13
b1001 =
b1100000000111001000 g
b1001 i
b111001000 J
b111001000 o
b111001000 |
b111001000 {
b1110010000000000000000000 M
b1110010000000000000000000 \
b111001000 [
b111001000 F
b111001000 d
b111001000 c
b0 ]
b110 ^
b10000000000000000001000 N
b10000000000000000001000 j
b10000000000000000001000 m
b10000000000000000001000 u
b10000000000000000001000 y
b100100000001100000000111001000 '
b100100000001100000000111001000 .
b100100000001100000000111001000 /
b100100000001100000000111001000 <
b100100000001100000000111001000 C
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 L
b10000000000000000000100 k
b10000000000000000000100 p
b10000000000000000000100 v
1!
#18
0!
#20
bx K
bx `
1T
x1
bx *
b11001010111111101011101010111110 V
b11001010111111101011101010111110 Q
bx )
bx :
bx O
bx W
bx e
b11001010111111101011101010111110 Y
b11001010111111101011101010111110 G
b11001010111111101011101010111110 S
b1000 q
b10000000000000000010100 n
b10000000000000000010100 s
b11 ;
b11 ?
b11 A
b11 R
16
09
bx 8
bx @
bx B
bx _
03
b10 =
b10 >
b100000000000000000010 g
b10 i
b10 h
b10 J
b10 o
b10 |
b10 {
b100000000000000000 M
b100000000000000000 \
b10 [
b10 F
b10 d
b10 c
b10000 ^
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 E
b11001010111111101011101010111110 H
b11001010111111101011101010111110 a
b10000000000000000001100 N
b10000000000000000001100 j
b10000000000000000001100 m
b10000000000000000001100 u
b10000000000000000001100 y
b1000000100000000000000000010 '
b1000000100000000000000000010 .
b1000000100000000000000000010 /
b1000000100000000000000000010 <
b1000000100000000000000000010 C
b10 -
b10000000000000000001000 &
b10000000000000000001000 4
b10000000000000000001000 L
b10000000000000000001000 k
b10000000000000000001000 p
b10000000000000000001000 v
1!
#22
0!
#24
1!
#25
b100000 #
