$date
	Wed Jun 14 17:06:33 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 5 memtoreg $end
$var wire 1 6 dojump $end
$var wire 1 7 dobranch $end
$var wire 5 8 destreg [4:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 32 : aluout [31:0] $end
$var wire 3 ; alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 < instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 = op [5:0] $end
$var wire 6 > funct [5:0] $end
$var reg 3 ? alucontrol [2:0] $end
$var reg 1 9 alusrcbimm $end
$var reg 5 @ destreg [4:0] $end
$var reg 1 7 dobranch $end
$var reg 1 6 dojump $end
$var reg 1 5 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 3 A alucontrol [2:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 B destreg [4:0] $end
$var wire 1 7 dobranch $end
$var wire 32 C instr [31:0] $end
$var wire 1 6 jump $end
$var wire 1 5 memtoreg $end
$var wire 32 D mfhi_wire [31:0] $end
$var wire 32 E mflo_wire [31:0] $end
$var wire 32 F readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 G writedata [31:0] $end
$var wire 32 H zero_left_wire [31:0] $end
$var wire 1 1 zero $end
$var wire 32 I srcbimm [31:0] $end
$var wire 32 J srcb [31:0] $end
$var wire 32 K srca [31:0] $end
$var wire 32 L signimm [31:0] $end
$var wire 32 M result [31:0] $end
$var wire 32 N pc [31:0] $end
$var wire 32 O paddwire [31:0] $end
$var wire 32 P lo [31:0] $end
$var wire 32 Q jal_wire [31:0] $end
$var wire 32 R hi [31:0] $end
$var wire 1 S enable_mul $end
$var wire 32 T aluout [31:0] $end
$scope module alu $end
$var wire 32 U a_and_b [31:0] $end
$var wire 32 V a_or_b [31:0] $end
$var wire 3 W alucontrol [2:0] $end
$var wire 32 X b [31:0] $end
$var wire 1 Y first_xor $end
$var wire 1 Z second_xor $end
$var wire 1 1 zero $end
$var wire 32 [ sum [31:0] $end
$var wire 32 \ result [31:0] $end
$var wire 32 ] extend [31:0] $end
$var wire 1 ^ cout1 $end
$var wire 32 _ b_multi [31:0] $end
$var wire 32 ` a [31:0] $end
$upscope $end
$scope module back $end
$var wire 16 a a [15:0] $end
$var wire 32 b y [31:0] $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 c ra1 [4:0] $end
$var wire 5 d ra2 [4:0] $end
$var wire 5 e wa3 [4:0] $end
$var wire 32 f wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 g rd2 [31:0] $end
$var wire 32 h rd1 [31:0] $end
$upscope $end
$scope module mul $end
$var wire 1 ! clk $end
$var wire 32 i mfhi [31:0] $end
$var wire 32 j mflo [31:0] $end
$var wire 1 S mul_enable $end
$var wire 32 k wd3hi [31:0] $end
$var wire 32 l wd3lo [31:0] $end
$upscope $end
$scope module padd $end
$var wire 16 m a [15:0] $end
$var wire 32 n y [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 32 o aluResult [31:0] $end
$var wire 1 ! clk $end
$var wire 1 7 dobranch $end
$var wire 1 6 dojump $end
$var wire 32 p jr_pc [31:0] $end
$var wire 26 q jumptarget [25:0] $end
$var wire 6 r least_sig_bits [5:0] $end
$var wire 6 s opCode [5:0] $end
$var wire 32 t pc_plus [31:0] $end
$var wire 32 u progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 v nextpc [31:0] $end
$var wire 32 w incpc [31:0] $end
$var wire 32 x branchpc [31:0] $end
$var wire 32 y branchoffset [31:0] $end
$var reg 32 z pc [31:0] $end
$scope module pcbranch $end
$var wire 32 { b [31:0] $end
$var wire 1 | cin $end
$var wire 32 } y [31:0] $end
$var wire 1 ~ cout $end
$var wire 32 !" a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 "" a [31:0] $end
$var wire 32 #" b [31:0] $end
$var wire 1 $" cin $end
$var wire 32 %" y [31:0] $end
$var wire 1 &" cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 '" a [15:0] $end
$var wire 32 (" y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1111011 ("
b1111011 '"
0&"
b10000000000000000000100 %"
0$"
b100 #"
b10000000000000000000000 ""
b10000000000000000000100 !"
0~
b10000000000000111110000 }
0|
b111101100 {
b10000000000000000000000 z
b1111011 y
b10000000000000111110000 x
b10000000000000000000100 w
b10000000000000000000100 v
b10000000000000000000000 u
b10000000000000000000100 t
b1001 s
b111011 r
b1000000000001111011 q
b0 p
b1111011 o
b1111011 n
b1111011 m
b1101101100011000 l
b0 k
bx j
bx i
b0 h
b11001010111111101011101010111110 g
b1111011 f
b100 e
b100 d
b0 c
b11110110000000000000000 b
b1111011 a
b0 `
b1111011 _
0^
b0 ]
b1111011 \
b1111011 [
0Z
0Y
b1111011 X
b10 W
b1111011 V
b0 U
b1111011 T
0S
b0 R
b10000000000000000000100 Q
b1101101100011000 P
b11110110000000000000000 O
b10000000000000000000000 N
b1111011 M
b1111011 L
b0 K
b11001010111111101011101010111110 J
b1111011 I
b1111011 H
b11001010111111101011101010111110 G
bx F
bx E
bx D
b100100000001000000000001111011 C
b100 B
b10 A
b100 @
b10 ?
b111011 >
b1001 =
b100100000001000000000001111011 <
b10 ;
b1111011 :
19
b100 8
07
06
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b100100000001000000000001111011 /
b100100000001000000000001111011 .
b0 -
b11001010111111101011101010111110 ,
bx +
b11110 *
b1111011 )
0(
b100100000001000000000001111011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
b1111011 $
b1111011 ,
b1111011 2
b1111011 G
b1111011 J
b1111011 g
1!
#5
0"
#6
0!
#8
b110010 *
b111001000 )
b111001000 :
b111001000 T
b111001000 \
b111001000 o
b111001000 [
b111001000 V
b111001000 _
b10000000000000000001000 v
b111001000 I
b111001000 X
bx M
bx f
b11100100000 {
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 G
b11001010111111101011101010111110 J
b11001010111111101011101010111110 g
b10000000000011100101000 x
b10000000000011100101000 }
b10 8
b10 @
b10 B
b10 e
b1000 >
b100000000111001000 q
b1000 r
b111001000 L
b111001000 y
b111001000 ("
b111001000 '"
b1110010000000000000000000 O
b1110010000000000000000000 b
b111001000 a
b111001000 H
b111001000 n
b111001000 m
b10 d
b10000000000000000001000 Q
b10000000000000000001000 t
b10000000000000000001000 w
b10000000000000000001000 !"
b10000000000000000001000 %"
b100100000000100000000111001000 '
b100100000000100000000111001000 .
b100100000000100000000111001000 /
b100100000000100000000111001000 <
b100100000000100000000111001000 C
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 N
b10000000000000000000100 u
b10000000000000000000100 z
b10000000000000000000100 ""
1!
#10
0!
#12
x^
x1
bx *
bx )
bx :
bx T
bx \
bx o
bx _
b0x ]
xZ
b10000000000000000001100 v
bx I
bx X
xY
bx [
1S
bx M
bx f
b11xx1x1x1111111x1x111x1x1x11111x V
bx00x0x0xxxxxxx0x0xxx0x0x0xxxxx0 U
b1100100 {
b11001010111111101011101010111110 K
b11001010111111101011101010111110 `
b11001010111111101011101010111110 h
b11001010111111101011101010111110 p
b10000000000000001110000 x
b10000000000000001110000 }
b11 ;
b11 ?
b11 A
b11 W
09
bx 8
bx @
bx B
bx e
03
b0 =
b11001 >
b1000100000000000011001 q
b0 s
b11001 r
b11001 L
b11001 y
b11001 ("
b11001 '"
b110010000000000000000 O
b110010000000000000000 b
b11001 a
b11001 H
b11001 n
b11001 m
b1 c
bx $
bx ,
bx 2
bx G
bx J
bx g
b10000000000000000001100 Q
b10000000000000000001100 t
b10000000000000000001100 w
b10000000000000000001100 !"
b10000000000000000001100 %"
b1000100000000000011001 '
b1000100000000000011001 .
b1000100000000000011001 /
b1000100000000000011001 <
b1000100000000000011001 C
b10 -
b10000000000000000001000 &
b10000000000000000001000 4
b10000000000000000001000 N
b10000000000000000001000 u
b10000000000000000001000 z
b10000000000000000001000 ""
1!
#14
0!
#16
b0 ]
0Z
b0 [
0^
0Y
b0 _
b0 I
b0 X
b10000000000000000010000 v
0S
b0 V
b0 U
b110000001001000 {
b1101101100011000 M
b1101101100011000 f
b0 K
b0 `
b0 h
b0 p
b0 $
b0 ,
b0 2
b0 G
b0 J
b0 g
b10000000110000001011000 x
b10000000110000001011000 }
b11 8
b11 @
b11 B
b11 e
13
b10010 >
b1100000010010 q
b10010 r
b1100000010010 L
b1100000010010 y
b1100000010010 ("
b1100000010010 '"
b11000000100100000000000000000 O
b11000000100100000000000000000 b
b1100000010010 a
b1100000010010 H
b1100000010010 n
b1100000010010 m
b0 c
b0 d
b10000000000000000010000 Q
b10000000000000000010000 t
b10000000000000000010000 w
b10000000000000000010000 !"
b10000000000000000010000 %"
b1100000010010 '
b1100000010010 .
b1100000010010 /
b1100000010010 <
b1100000010010 C
b11 -
b1101101100011000 E
b1101101100011000 j
b0 D
b0 i
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 N
b10000000000000000001100 u
b10000000000000000001100 z
b10000000000000000001100 ""
1!
#18
0!
#20
b10000000000000000010100 v
b1000000001000000 {
bx M
bx f
b10000001000000001010100 x
b10000001000000001010100 }
b100 8
b100 @
b100 B
b100 e
b10000 >
b10000000010000 q
b10000 r
b10000000010000 L
b10000000010000 y
b10000000010000 ("
b10000000010000 '"
b100000000100000000000000000000 O
b100000000100000000000000000000 b
b10000000010000 a
b10000000010000 H
b10000000010000 n
b10000000010000 m
b10000000000000000010100 Q
b10000000000000000010100 t
b10000000000000000010100 w
b10000000000000000010100 !"
b10000000000000000010100 %"
b10000000010000 '
b10000000010000 .
b10000000010000 /
b10000000010000 <
b10000000010000 C
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 N
b10000000000000000010000 u
b10000000000000000010000 z
b10000000000000000010000 ""
1!
#22
0!
#24
b0x ]
xZ
bx U
xY
bx [
x^
xS
bx v
x~
bx _
bx V
bx00 {
bx I
bx X
bx K
bx `
bx h
bx p
bx $
bx ,
bx 2
bx G
bx J
bx g
bx x
bx }
x6
x5
x(
x7
x9
bx 8
bx @
bx B
bx e
x3
bx =
bx >
bx q
bx s
bx r
bx L
bx y
bx ("
bx '"
bx0000000000000000 O
bx0000000000000000 b
bx a
b0xxxxxxxxxxxxxxxx H
b0xxxxxxxxxxxxxxxx n
bx m
bx c
bx d
b10000000000000000011000 Q
b10000000000000000011000 t
b10000000000000000011000 w
b10000000000000000011000 !"
b10000000000000000011000 %"
bx '
bx .
bx /
bx <
bx C
b101 -
b10000000000000000010100 &
b10000000000000000010100 4
b10000000000000000010100 N
b10000000000000000010100 u
b10000000000000000010100 z
b10000000000000000010100 ""
1!
#26
0!
#28
bx Q
bx t
bx w
bx !"
bx %"
x&"
bx -
bx &
bx 4
bx N
bx u
bx z
bx ""
1!
#29
b1 #
